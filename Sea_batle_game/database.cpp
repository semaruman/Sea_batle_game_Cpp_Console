#pragma once
// Директива препроцессора, гарантирующая, что файл будет включён только один раз при компиляции

#include <iostream>   // Подключение стандартной библиотеки для ввода-вывода
#include <fstream>    // Подключение библиотеки для работы с файлами

// Функция для добавления строки текста в бинарную базу данных
void add_to_database(const char* text) {
    // Открываем файл "database.bin" в режиме добавления и бинарного режима
    std::ofstream file("database.bin", std::ios::binary | std::ios::app);

    // Проверка, успешно ли открылся файл
    if (!file) {
        std::cerr << "Ошибка открытия файла для записи\n"; // Вывод сообщения об ошибке
        return; // Завершение функции при ошибке
    }

    // Вычисляем длину строки, пока не достигнем нулевого символа '\0'
    size_t len = 0;
    while (text[len] != '\0') {
        ++len;
    }

    // Записываем длину строки в файл (чтобы при чтении знать, сколько символов читать)
    file.write(reinterpret_cast<const char*>(&len), sizeof(len));
    // Проверка успешности записи длины
    if (!file) {
        std::cerr << "Ошибка записи длины\n"; // Сообщение об ошибке
        return; // Завершение функции
    }

    // Записываем сам текст в файл, длиной len байт
    file.write(text, len);
    // Проверка успешности записи текста
    if (!file) {
        std::cerr << "Ошибка записи текста\n"; // Сообщение об ошибке
        return; // Завершение функции
    }
    // Файл автоматически закрывается при выходе из функции, благодаря RAII
}

// Функция для чтения и печати всех записей из базы данных
void print_database() {
    // Открываем файл "database.bin" для чтения в бинарном режиме
    std::ifstream file("database.bin", std::ios::binary);

    // Проверка, успешно ли открылся файл
    if (!file) {
        std::cerr << "Ошибка открытия файла для чтения\n"; // Сообщение об ошибке
        return; // Завершение функции
    }

    // Бесконечный цикл для последовательного чтения всех записей
    while (true) {
        size_t len; // Переменная для хранения длины текущей строки

        // Читаем длину строки из файла
        file.read(reinterpret_cast<char*>(&len), sizeof(len));
        // Проверяем, достигли ли конца файла или произошла ошибка
        if (file.eof()) break; // Конец файла — выходим из цикла
        if (!file) {
            std::cerr << "Ошибка чтения длины\n"; // Сообщение об ошибке
            break; // Завершаем чтение при ошибке
        }

        // Выделяем динамическую память для хранения строки + 1 байт для нулевого терминатора
        char* buffer = new char[len + 1];

        // Читаем текст указанной длины
        file.read(buffer, len);
        // Проверяем успешность чтения
        if (!file) {
            std::cerr << "Ошибка чтения текста\n"; // Сообщение об ошибке
            delete[] buffer; // Освобождаем память
            break; // Завершаем чтение
        }

        // Добавляем нулевой терминатор для корректного вывода как строки
        buffer[len] = '\0';

        // Выводим строку на экран
        std::cout << buffer << std::endl;

        // Освобождаем выделенную память
        delete[] buffer;
    }
}